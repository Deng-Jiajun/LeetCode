> 突然感觉2000多题好像是有点多，就我这磨磨唧唧的可能这辈子刷不完。还是按专题刷吧，顺序是 https://programmercarl.com/ 里的
# 数组

## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

[题解](https://programmercarl.com/0704.二分查找.html#_704-二分查找)

二分法思路简单，但是要注意，二分法要求数组元素**有序且唯一**。有序是二分法的前提，如果元素不唯一，也能找得到，但是返回的下标也**可能不唯一**

然后是区间的开闭问题，也就是搜索范围是否包括边界，区间的选取问题会导致 `left` 和 `right` 的比较是否要 `=`，`middle` 的改变是否要 `+/- 1`，还是直接 `=`。区间选取没有优劣，但是要保证其统一，本质上还是边界处理问题，这里我选择全闭 `[ ]`

### 相关题目

#### [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

[题解](https://programmercarl.com/0035.搜索插入位置.html)

这题和 704 一样，二分查找，区别在于没找到的时候要返回**按序插入的位置**

所以如果没找到，这个位置这么确定呢？

大致分为三种情况

1. 头部插入（0）

   这种情况位置 = middle（也就是 **left**，因为这个值太小，left没变过，一直是0）

2. 中间插入（numSize)

   这种情况，如果 target < nums[middle]，那位置就是 middle（也就是 **left**，因为要往左边找）

   ​					如果 target > nums[middle]，那位置就是 middle+1（也就是 **left**，因为要往右边找）

3. 尾部插入（middle?）

   这种情况位置 = middle+1（也就是**left**，因为太大，所以要往右)

因此，最终结论是：**全都返回 left 就行了**

这个结果的奇妙之处在于，最后一次循环，**middle=left=right**，因为左边找不到比 middle 小的数了，所以如果目标值比当前的值小，则目标值就要插到当前的位置，即 left，而 right 根据逻辑会等于 middle-1，不影响 left 的值；而如果目标值比当前的值大，则目标值要插到当前位置的后面，即 middle+1，而 left 根据逻辑会等于 middle+1，而这个 left 的新值正好就是我们需要的。（💡注意，同样的，也可以返回 **right+1**）

❗把握住一点：如果没有找到目标元素，则右指针会指向最大小于 target 的值，左指针指向最小大于 target 的值。（注意，这指的是 left 和 right 还没有改变的时候）**这个规律很明确，但是太拗口，实际上，如果逻辑清晰的情况下，这个规律并不好用，因为这句话本身太过复杂**

其实还有一个简单的办法：直接在 left==right 但是当前值又不是目标值的时候，直接判断 target 和当前值的大小，target 大于当前值，就直接返回 middle+1，反之返回 middle-1，当然这样会增加时间复杂度，不过本着写的就是垃圾代码的厚脸皮心态，这种做法也不是不行（没有暴力破解就不错了）



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

[题解](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)

首先 O(log n) 的时间复杂度指明了需要使用二分查找

最朴素的想法，在二分法的基础上，找到 `targetIndex` 后，**一格格地左右探**，就能探明起始位置。但是这一块的时间复杂度是这里的复杂度是 O(m)（m是目标值的数量） ，显然不满足 O(log n) （总时间复杂度是O(log n + m) ）。时间复杂度不符合要求的原因也很简单，在查找到目标元素后，**二分查找退化为了线性查找**，因而时间复杂度不符合要求

要满足 O(log n) 的时间复杂度，需要在 `[left, targetIndex-1]` 和 `[targetIndex+1, right]` 里**继续二分查找**，在左半边里找到第一个 target，在右半边找到最后一个 target

至于怎么找第一个和最后一个，实际上要做的是**改写普通的二分查找**：对于**左半边**，在找到 target 时，看前一个元素是不是也是 target，如果是，就**继续二分查找的循环**，如果不是，就返回它的下标；对于**右半边**，也类似，在找到 target 时，看后一个元素是不是也是 target，如果是，就**继续二分查找的循环**，如果不是，就返回它的下标（注意判断边界溢出问题）

❗题目是要求 O(log n) 的时间复杂度，所以直接怼两次二分查找，2*(log n) = O(log n)，是符合要求的

> ❗❗69 和 367 的边界判定有问题，AC 有水分

#### [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

数学题，太难了😭

数学知识：0 和 1 的平方根是它本身；x 的平方根总小于 x/2（x>4)

二分查找就是不断逼近平方根

#### [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

和 69 题一样，二分法解决问题

如果条件判断的时候发现 `middle==num/middle` 且 `num % middle == 0`，就返回 `true`，否则返回 `false` 其他情况下走出循环就返回 `false`
